一、解题思路及核心要点
    由于是循位置搜索，故本题运用双向链表这一数据结构，起初我并未想到用循环链表，就想着仿照讲义上的链表搭建，此外我设置了header和trailer元素，在一些条件的判断上很有帮助。链表规header到trailer为顺时针，因此逆时针就是不断寻找前驱pre,我在类中定义好了将元素e从当前节点回溯m个节点插入的接口，实现从前一应聘者出发，沿逆时针方向围圆桌走过m 人的功能，具体实现思路已在代码中注释。

二、遇到的问题及解决办法
    主要的问题是指针访问存在错误，其原因在于前插函数insertaspre(post(T) node,int &e)的实现存在问题，正是犯了提示中讲到的错误：增删前驱后继时没有注意次序。最重要的函数insertaspre_m的实现过程也走了一些弯路。比如在其中调用寻秩函数rank（），造成了嵌套，提高了时间复杂度，后加以改进。

三、复杂度分析
1、时间复杂度：分配id和面试者进场出场，均为O（n）复杂度，面试者进场时调用insertaspre_m，而因为m=m%getsize();对n取了模，因此在m<n时，复杂度不会超过O（nm）,在m>n时，复杂度不会超过O（n*n）
2、空间复杂度：id数组的建立：new int[n]，复杂度O（n）。